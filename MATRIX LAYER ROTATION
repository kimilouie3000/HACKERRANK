using System;

class Solution
{
    static void Main(string[] args)
    {
        var inputs = Console.ReadLine().Split();
        int m = int.Parse(inputs[0]);
        int n = int.Parse(inputs[1]);
        int r = int.Parse(inputs[2]);

        int[,] matrix = new int[m, n];
        for (int i = 0; i < m; i++)
        {
            var row = Console.ReadLine().Split();
            for (int j = 0; j < n; j++)
            {
                matrix[i, j] = int.Parse(row[j]);
            }
        }

        matrixRotation(matrix, m, n, r);

        // Print rotated matrix
        for (int i = 0; i < m; i++)
        {
            for (int j = 0; j < n; j++)
            {
                Console.Write(matrix[i, j] + (j == n - 1 ? "\n" : " "));
            }
        }
    }

    static void matrixRotation(int[,] matrix, int m, int n, int r)
    {
        int layers = Math.Min(m, n) / 2;

        for (int layer = 0; layer < layers; layer++)
        {
            int top = layer;
            int left = layer;
            int bottom = m - 1 - layer;
            int right = n - 1 - layer;

            int perimeter = 2 * (bottom - top + right - left);

            int rotations = r % perimeter;  // effective rotations

            // Extract elements of the layer into a 1D list
            int[] elements = new int[perimeter];
            int idx = 0;

            // top row left to right
            for (int j = left; j <= right; j++) elements[idx++] = matrix[top, j];
            // right column top+1 to bottom-1
            for (int i = top + 1; i < bottom; i++) elements[idx++] = matrix[i, right];
            // bottom row right to left
            for (int j = right; j >= left; j--) elements[idx++] = matrix[bottom, j];
            // left column bottom-1 to top+1
            for (int i = bottom - 1; i > top; i--) elements[idx++] = matrix[i, left];

            // Rotate elements anti-clockwise by rotations: shift left by rotations
            int[] rotated = new int[perimeter];
            for (int i = 0; i < perimeter; i++)
            {
                rotated[i] = elements[(i + rotations) % perimeter];
            }

            // Put rotated elements back to matrix layer
            idx = 0;
            for (int j = left; j <= right; j++) matrix[top, j] = rotated[idx++];
            for (int i = top + 1; i < bottom; i++) matrix[i, right] = rotated[idx++];
            for (int j = right; j >= left; j--) matrix[bottom, j] = rotated[idx++];
            for (int i = bottom - 1; i > top; i--) matrix[i, left] = rotated[idx++];
        }
    }
}
